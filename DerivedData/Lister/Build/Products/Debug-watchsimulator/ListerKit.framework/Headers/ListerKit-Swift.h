// Generated by Apple Swift version 2.0 (swiftlang-700.0.38.1 clang-700.0.53)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if defined(__has_include) && __has_include(<uchar.h>)
# include <uchar.h>
#elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
#endif

typedef struct _NSZone NSZone;

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted) 
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
#endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSUndoManager;
@class List;
@class ListItem;
@class NSIndexSet;


/// The ``AllListItemsPresenter`` list presenter class is responsible for managing how a list is displayed in both the iOS and OS X apps. The ``AllListItemsPresenter`` class conforms to ``ListPresenterType`` so consumers of this class can work with the presenter with a common interface.
///
/// When a list is presented with an <code>AllListItemsPresenter
/// </code>, all of the list items with a list are presented
/// (as the name suggests!). When the list items are displayed to a user, the incomplete list items are
/// ordered before the complete list items. This order is determined when <code>setList(_:)
/// </code> is called on the
/// <code>AllListItemsPresenter
/// </code> instance. The presenter then reorders the list items accordingly, calling the
/// delegate methods with any relevant changes.
///
/// An <code>AllListItemsPresenter
/// </code> can be interacted with in a few ways. It can insert, remove, toggle, move, and
/// update list items. It can also change the color of the presented list. All of these changes get funnelled
/// through callbacks to the delegate (a <code>ListPresenterDelegate
/// </code>). For more information about how the delegate
/// pattern for the <code>ListPresenterType
/// </code> is architected, see the <code>ListPresenterType
/// </code> definition. What's unique
/// about the <code>AllListItemsPresenter
/// </code> with respect to the delegate methods is that the <code>AllListItemsPresenter
/// </code>
/// has an undo manager. Whenever the presentation of the list is manipulated (as described above), the
/// presenter pushes an undo operation that reverses the manipulation onto the undo stack. For example, if a
/// list item is inserted, the <code>AllListItemsPresenter
/// </code> instance registers an undo operation to remove the list
/// item.  When a user performs an undo in either the iOS or OS X app, the list item that was inserted is
/// removed.  The remove operation gets funnelled into the same delegate that inserted the list item. By
/// abstracting these operations away into a presenter and delegate architecture, we're not only able to
/// easily test the code that manipulates the list, but we're also able to test the undo registration code.
///
/// One thing to note is that when a list item is toggled in the <code>AllListItemsPresenter
/// </code>, it is moved from an
/// index in its current completion state to an index opposite of the list items completion state. For
/// example, if a list item that is complete is toggled, it will move to an incomplete index (e.g. index 0).
/// For the <code>AllListItemsPresenter
/// </code>, a toggle represents both the list item moving as well as the list item
/// being updated.
SWIFT_CLASS("_TtC9ListerKit21AllListItemsPresenter")
@interface AllListItemsPresenter : NSObject

/// The undo manager to register undo events with when the ``AllListItemsPresenter`` instance is manipulated.
@property (nonatomic) NSUndoManager * __nullable undoManager;
@property (nonatomic, readonly) List * __nonnull archiveableList;
@property (nonatomic, readonly, copy) NSArray<ListItem *> * __nonnull presentedListItems;

/// Sets the list that should be presented. Calling ``setList(_:)`` on an ``AllListItemsPresenter`` does not trigger any undo registrations. Calling ``setList(_:)`` also removes all of the undo actions from the undo manager.
- (void)setList:(List * __nonnull)newList;

/// Inserts ``listItem`` into the list. If the list item is incomplete, ``listItem`` is inserted at index 0. Otherwise, it is inserted at the end of the list. Inserting a list item calls the delegate's ``listPresenter(_:didInsertListItem:atIndex:)`` method. Calling this method registers an undo event to remove the list item.
///
/// \param listItem The <code>ListItem
/// </code> instance to insert.
- (void)insertListItem:(ListItem * __nonnull)listItem;

/// Inserts ``listItems`` into the list. The net effect of this is calling ``insertListItem(_:)`` for each ``ListItem`` instance in ``listItems``. Inserting list items calls the delegate's ``listPresenter(_:didInsertListItem:atIndex:)`` method for each inserted list item after an individual list item has been inserted. Calling this method registers an undo event to remove each list item.
///
/// \param listItems The <code>ListItem
/// </code> instances to insert.
- (void)insertListItems:(NSArray<ListItem *> * __nonnull)listItems;

/// Removes ``listItem`` from the list. Removing the list item calls the delegate's ``listPresenter(_:didRemoveListItem:atIndex:)`` method for the removed list item after it has been removed. Calling this method registers an undo event to insert the list item at its previous index.
///
/// \param listItem The <code>ListItem
/// </code> instance to remove.
- (void)removeListItem:(ListItem * __nonnull)listItem;

/// Removes ``listItems`` from the list. Removing list items calls the delegate's ``listPresenter(_:didRemoveListItem:atIndex:)`` method for each of the removed list items after an individual list item has been removed. Calling this method registers an undo event to insert the list items that were removed at their previous indexes.
///
/// \param listItems The <code>ListItem
/// </code> instances to remove.
- (void)removeListItems:(NSArray<ListItem *> * __nonnull)listItems;

/// Updates the ``text`` property of ``listItem`` with ``newText``. Updating the text property of the list item calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for the list item that was updated. Calling this method registers an undo event to revert the text change back to the text before the method was invoked.
///
/// \param listItem The <code>ListItem
/// </code> instance whose text needs to be updated.
///
/// \param newText The new text for <code>listItem
/// </code>.
- (void)updateListItem:(ListItem * __nonnull)listItem withText:(NSString * __nonnull)newText;

/// Tests whether ``listItem`` is in the list and can be moved from its current index in the list to ``toIndex``.
///
/// \param listItem The item to test for insertion.
///
/// \param toIndex The index to use to determine if <code>listItem
/// </code> can be inserted into the list.
///
/// \returns  Whether or not <code>listItem
/// </code> can be moved to <code>toIndex
/// </code>.
- (BOOL)canMoveListItem:(ListItem * __nonnull)listItem toIndex:(NSInteger)toIndex;

/// Moves ``listItem`` to ``toIndex``. Moving the ``listItem`` to a new index calls the delegate's ``listPresenter(_:didMoveListItem:fromIndex:toIndex)`` method with the moved list item. Calling this method registers an undo event that moves the list item from its new index back to its old index.
///
/// \param listItem The list item to move.
///
/// \param toIndex The index to move <code>listItem
/// </code> to.
- (void)moveListItem:(ListItem * __nonnull)listItem toIndex:(NSInteger)toIndex;

/// Toggles ``listItem`` within the list. This method moves a complete list item to an incomplete index at the beginning of the list, or it moves an incomplete list item to a complete index at the last index of the list. The list item is also updated in place since the completion state is flipped. Toggling a list item calls the delegate's ``listPresenter(_:didMoveListItem:fromIndex:toIndex:)`` method followed by the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method. Calling this method registers an undo event that toggles the list item back to its original location and completion state.
///
/// \param listItem The list item to toggle.
- (void)toggleListItem:(ListItem * __nonnull)listItem;

/// Set the completion state of all of the presented list items to ``completionState``. This method does not move the list items around in any way. Changing the completion state on all of the list items calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for each list item that has been updated. Calling this method registers an undo event that sets the completion states for all of the list items back to the original state before the method was invoked.
///
/// \param completionState The value that all presented list item instances should have as their <code>isComplete
/// </code> property.
- (void)updatePresentedListItemsToCompletionState:(BOOL)completionState;

/// Returns the list items at each index in ``indexes`` within the ``presentedListItems`` array.
///
/// \param indexes The indexes that correspond to the list items that should be retrieved from <code>presentedListItems
/// </code>.
///
/// \returns  The list items that are located at each index in <code>indexes
/// </code> within <code>presentedListItems
/// </code>.
- (NSArray<ListItem *> * __nonnull)listItemsAtIndexes:(NSIndexSet * __nonnull)indexes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The ``IncompleteListItemsPresenter`` list presenter is responsible for managing the how a list's incomplete list items are displayed in the iOS and OS X Today widgets as well as the Lister WatchKit app. The ``IncompleteListItemsPresenter`` class conforms to ``ListPresenterType`` so consumers of this class can work with the presenter using a common interface.
///
/// When a list is initially presented with an <code>IncompleteListItemsPresenter
/// </code>, only the incomplete list items
/// are presented. That can change, however, if a user toggles list items (changing the list item's completion
/// state). An <code>IncompleteListItemsPresenter
/// </code> always shows the list items that are initially presented (unless
/// they are removed from the list from another device). If an <code>IncompleteListItemsPresenter
/// </code> stops presenting
/// a list that has some presented list items that are complete (after toggling them) and another
/// <code>IncompleteListItemsPresenter
/// </code> presents the same list, the presenter displays <em>only</em> the incomplete list
/// items.
///
/// The <code>IncompleteListItemsPresenter
/// </code> can be interacted with in a two ways. <code>ListItem
/// </code> instances can be
/// toggled individually or using a batch update, and the color of the list presenter can be changed.  All of
/// these methods trigger calls to the delegate to be notified about inserted list items, removed list items,
/// updated list items, etc.
SWIFT_CLASS("_TtC9ListerKit28IncompleteListItemsPresenter")
@interface IncompleteListItemsPresenter : NSObject
@property (nonatomic, readonly) List * __nonnull archiveableList;
@property (nonatomic, readonly, copy) NSArray<ListItem *> * __nonnull presentedListItems;

/// This methods determines the changes betwen the current list and the new list provided, and it notifies the delegate accordingly. The delegate is notified of all changes except for reordering list items (an implementation detail). If the list is the initial list to be presented, we just reload all of the data.
- (void)setList:(List * __nonnull)newList;

/// Toggles ``listItem`` within the list. This method keeps the list item in the same place, but it toggles the completion state of the list item. Toggling a list item calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method.
///
/// \param listItem The list item to toggle.
- (void)toggleListItem:(ListItem * __nonnull)listItem;

/// Sets all of the presented list item's completion states to ``completionState``. This method does not move the list items around in any way. Changing the completion state on all of the list items calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for each list item that has been updated.
///
/// \param completionState The value that all presented list item instances should have as their <code>isComplete
/// </code> property.
- (void)updatePresentedListItemsToCompletionState:(BOOL)completionState;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSCoder;


/// The ``List`` class manages the color of a list and each ``ListItem`` object. ``List`` objects are copyable and archivable. ``List`` objects are normally associated with an object that conforms to ``ListPresenterType``. This object manages how the list is presented, archived, and manipulated. To ensure that the ``List`` class is unarchivable from an instance that was archived in the Objective-C version of Lister, the ``List`` class declaration is annotated with @objc(AAPLList). This annotation ensures that the runtime name of the ``List`` class is the same as the ``AAPLList`` class defined in the Objective-C version of the app. It also allows the Objective-C version of Lister to unarchive a ``List`` instance that was archived in the Swift version.
SWIFT_CLASS("AAPLList")
@interface List : NSObject <NSCoding, NSCopying>

/// The list's items.
@property (nonatomic, copy) NSArray<ListItem *> * __nonnull items;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * __nonnull)aCoder;
- (id __nonnull)copyWithZone:(NSZone * __null_unspecified)zone;

/// Overrides NSObject's isEqual(_:) instance method to return whether the list is equal to another list. A ``List`` is considered to be equal to another ``List`` if its color and items are equal.
///
/// \param object Any object, or nil.
///
/// \returns  <code>true
/// </code> if the object is a <code>List
/// </code> and it has the same color and items as the receiving
/// instance. <code>false
/// </code> otherwise.
- (BOOL)isEqual:(id __nullable)object;
@property (nonatomic, readonly, copy) NSString * __nonnull debugDescription;
@end



/// A ``ListItem`` object is composed of a text property, a completion status, and an underlying opaque identity that distinguishes one ``ListItem`` object from another. ``ListItem`` objects are copyable and archivable. To ensure that the ``ListItem`` class is unarchivable from an instance that was archived in the Objective-C version of Lister, the ``ListItem`` class declaration is annotated with @objc(AAPLListItem). This annotation ensures that the runtime name of the ``ListItem`` class is the same as the ``AAPLListItem`` class defined in the Objective-C version of the app. It also allows the Objective-C version of Lister to unarchive a ``ListItem`` instance that was archived in the Swift version.
SWIFT_CLASS("AAPLListItem")
@interface ListItem : NSObject <NSCoding, NSCopying>

/// The text content for a ``ListItem``.
@property (nonatomic, copy) NSString * __nonnull text;

/// Whether or not this ``ListItem`` is complete.
@property (nonatomic) BOOL isComplete;

/// Initializes a ``ListItem`` instance with the designated text and completion state.
///
/// \param text The text content of the list item.
///
/// \param complete The item's initial completion state.
- (nonnull instancetype)initWithText:(NSString * __nonnull)text complete:(BOOL)complete;

/// Initializes a ``ListItem`` instance with the designated text and a default value for ``isComplete``. The default value for ``isComplete`` is false.
///
/// \param text The intended text content of the list item.
- (nonnull instancetype)initWithText:(NSString * __nonnull)text;
- (id __nonnull)copyWithZone:(NSZone * __null_unspecified)zone;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * __nonnull)encoder;

/// Resets the underlying identity of the ``ListItem``. If a copy of this item is made, and a call to refreshIdentity() is made afterward, the items will no longer be equal.
- (void)refreshIdentity;

/// Overrides NSObject's isEqual(_:) instance method to return whether or not the list item is equal to another list item. A ``ListItem`` is considered to be equal to another ``ListItem`` if the underyling identities of the two list items are equal.
///
/// \param object Any object, or nil.
///
/// \returns  <code>true
/// </code> if the object is a <code>ListItem
/// </code> and it has the same underlying identity as the
/// receiving instance. <code>false
/// </code> otherwise.
- (BOOL)isEqual:(id __nullable)object;
@property (nonatomic, readonly, copy) NSString * __nonnull debugDescription;
@end

#pragma clang diagnostic pop
