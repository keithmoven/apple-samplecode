// Generated by Apple Swift version 2.0 (swiftlang-700.0.38.1 clang-700.0.53)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if defined(__has_include) && __has_include(<uchar.h>)
# include <uchar.h>
#elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
#endif

typedef struct _NSZone NSZone;

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted) 
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
#endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import UIKit;
@import CoreGraphics;
@import QuartzCore;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSUndoManager;
@class List;
@class ListItem;
@class NSIndexSet;


/// The ``AllListItemsPresenter`` list presenter class is responsible for managing how a list is displayed in both the iOS and OS X apps. The ``AllListItemsPresenter`` class conforms to ``ListPresenterType`` so consumers of this class can work with the presenter with a common interface.
///
/// When a list is presented with an <code>AllListItemsPresenter
/// </code>, all of the list items with a list are presented
/// (as the name suggests!). When the list items are displayed to a user, the incomplete list items are
/// ordered before the complete list items. This order is determined when <code>setList(_:)
/// </code> is called on the
/// <code>AllListItemsPresenter
/// </code> instance. The presenter then reorders the list items accordingly, calling the
/// delegate methods with any relevant changes.
///
/// An <code>AllListItemsPresenter
/// </code> can be interacted with in a few ways. It can insert, remove, toggle, move, and
/// update list items. It can also change the color of the presented list. All of these changes get funnelled
/// through callbacks to the delegate (a <code>ListPresenterDelegate
/// </code>). For more information about how the delegate
/// pattern for the <code>ListPresenterType
/// </code> is architected, see the <code>ListPresenterType
/// </code> definition. What's unique
/// about the <code>AllListItemsPresenter
/// </code> with respect to the delegate methods is that the <code>AllListItemsPresenter
/// </code>
/// has an undo manager. Whenever the presentation of the list is manipulated (as described above), the
/// presenter pushes an undo operation that reverses the manipulation onto the undo stack. For example, if a
/// list item is inserted, the <code>AllListItemsPresenter
/// </code> instance registers an undo operation to remove the list
/// item.  When a user performs an undo in either the iOS or OS X app, the list item that was inserted is
/// removed.  The remove operation gets funnelled into the same delegate that inserted the list item. By
/// abstracting these operations away into a presenter and delegate architecture, we're not only able to
/// easily test the code that manipulates the list, but we're also able to test the undo registration code.
///
/// One thing to note is that when a list item is toggled in the <code>AllListItemsPresenter
/// </code>, it is moved from an
/// index in its current completion state to an index opposite of the list items completion state. For
/// example, if a list item that is complete is toggled, it will move to an incomplete index (e.g. index 0).
/// For the <code>AllListItemsPresenter
/// </code>, a toggle represents both the list item moving as well as the list item
/// being updated.
SWIFT_CLASS("_TtC9ListerKit21AllListItemsPresenter")
@interface AllListItemsPresenter : NSObject

/// The undo manager to register undo events with when the ``AllListItemsPresenter`` instance is manipulated.
@property (nonatomic) NSUndoManager * __nullable undoManager;
@property (nonatomic, readonly) List * __nonnull archiveableList;
@property (nonatomic, readonly, copy) NSArray<ListItem *> * __nonnull presentedListItems;

/// Sets the list that should be presented. Calling ``setList(_:)`` on an ``AllListItemsPresenter`` does not trigger any undo registrations. Calling ``setList(_:)`` also removes all of the undo actions from the undo manager.
- (void)setList:(List * __nonnull)newList;

/// Inserts ``listItem`` into the list. If the list item is incomplete, ``listItem`` is inserted at index 0. Otherwise, it is inserted at the end of the list. Inserting a list item calls the delegate's ``listPresenter(_:didInsertListItem:atIndex:)`` method. Calling this method registers an undo event to remove the list item.
///
/// \param listItem The <code>ListItem
/// </code> instance to insert.
- (void)insertListItem:(ListItem * __nonnull)listItem;

/// Inserts ``listItems`` into the list. The net effect of this is calling ``insertListItem(_:)`` for each ``ListItem`` instance in ``listItems``. Inserting list items calls the delegate's ``listPresenter(_:didInsertListItem:atIndex:)`` method for each inserted list item after an individual list item has been inserted. Calling this method registers an undo event to remove each list item.
///
/// \param listItems The <code>ListItem
/// </code> instances to insert.
- (void)insertListItems:(NSArray<ListItem *> * __nonnull)listItems;

/// Removes ``listItem`` from the list. Removing the list item calls the delegate's ``listPresenter(_:didRemoveListItem:atIndex:)`` method for the removed list item after it has been removed. Calling this method registers an undo event to insert the list item at its previous index.
///
/// \param listItem The <code>ListItem
/// </code> instance to remove.
- (void)removeListItem:(ListItem * __nonnull)listItem;

/// Removes ``listItems`` from the list. Removing list items calls the delegate's ``listPresenter(_:didRemoveListItem:atIndex:)`` method for each of the removed list items after an individual list item has been removed. Calling this method registers an undo event to insert the list items that were removed at their previous indexes.
///
/// \param listItems The <code>ListItem
/// </code> instances to remove.
- (void)removeListItems:(NSArray<ListItem *> * __nonnull)listItems;

/// Updates the ``text`` property of ``listItem`` with ``newText``. Updating the text property of the list item calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for the list item that was updated. Calling this method registers an undo event to revert the text change back to the text before the method was invoked.
///
/// \param listItem The <code>ListItem
/// </code> instance whose text needs to be updated.
///
/// \param newText The new text for <code>listItem
/// </code>.
- (void)updateListItem:(ListItem * __nonnull)listItem withText:(NSString * __nonnull)newText;

/// Tests whether ``listItem`` is in the list and can be moved from its current index in the list to ``toIndex``.
///
/// \param listItem The item to test for insertion.
///
/// \param toIndex The index to use to determine if <code>listItem
/// </code> can be inserted into the list.
///
/// \returns  Whether or not <code>listItem
/// </code> can be moved to <code>toIndex
/// </code>.
- (BOOL)canMoveListItem:(ListItem * __nonnull)listItem toIndex:(NSInteger)toIndex;

/// Moves ``listItem`` to ``toIndex``. Moving the ``listItem`` to a new index calls the delegate's ``listPresenter(_:didMoveListItem:fromIndex:toIndex)`` method with the moved list item. Calling this method registers an undo event that moves the list item from its new index back to its old index.
///
/// \param listItem The list item to move.
///
/// \param toIndex The index to move <code>listItem
/// </code> to.
- (void)moveListItem:(ListItem * __nonnull)listItem toIndex:(NSInteger)toIndex;

/// Toggles ``listItem`` within the list. This method moves a complete list item to an incomplete index at the beginning of the list, or it moves an incomplete list item to a complete index at the last index of the list. The list item is also updated in place since the completion state is flipped. Toggling a list item calls the delegate's ``listPresenter(_:didMoveListItem:fromIndex:toIndex:)`` method followed by the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method. Calling this method registers an undo event that toggles the list item back to its original location and completion state.
///
/// \param listItem The list item to toggle.
- (void)toggleListItem:(ListItem * __nonnull)listItem;

/// Set the completion state of all of the presented list items to ``completionState``. This method does not move the list items around in any way. Changing the completion state on all of the list items calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for each list item that has been updated. Calling this method registers an undo event that sets the completion states for all of the list items back to the original state before the method was invoked.
///
/// \param completionState The value that all presented list item instances should have as their <code>isComplete
/// </code> property.
- (void)updatePresentedListItemsToCompletionState:(BOOL)completionState;

/// Returns the list items at each index in ``indexes`` within the ``presentedListItems`` array.
///
/// \param indexes The indexes that correspond to the list items that should be retrieved from <code>presentedListItems
/// </code>.
///
/// \returns  The list items that are located at each index in <code>indexes
/// </code> within <code>presentedListItems
/// </code>.
- (NSArray<ListItem *> * __nonnull)listItemsAtIndexes:(NSIndexSet * __nonnull)indexes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class CheckBoxLayer;
@class NSCoder;

SWIFT_CLASS("_TtC9ListerKit8CheckBox")
@interface CheckBox : UIControl
@property (nonatomic) BOOL isChecked;
@property (nonatomic) CGFloat strokeFactor;
@property (nonatomic) CGFloat insetFactor;
@property (nonatomic) CGFloat markInsetFactor;
- (void)didMoveToWindow;
+ (Class __nonnull)layerClass;
- (void)tintColorDidChange;
@property (nonatomic, readonly) CheckBoxLayer * __nonnull checkBoxLayer;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC9ListerKit13CheckBoxLayer")
@interface CheckBoxLayer : CALayer
@property (nonatomic) CGColorRef __nonnull tintColor;
@property (nonatomic) BOOL isChecked;
@property (nonatomic) CGFloat strokeFactor;
@property (nonatomic) CGFloat insetFactor;
@property (nonatomic) CGFloat markInsetFactor;
- (void)drawInContext:(CGContextRef __nonnull)context;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLayer:(id __nonnull)layer OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@protocol ListCoordinatorDelegate;
@class NSURL;


/// An instance that conforms to the ``ListCoordinator`` protocol is responsible for implementing entry points in order to communicate with a ``ListCoordinatorDelegate``. In the case of Lister, this is the ``ListsController`` instance. The main responsibility of a ``ListCoordinator`` is to track different ``NSURL`` instances that are important. For example, in Lister there are two types of storage mechanisms: local and iCloud based storage. The iCloud coordinator is responsible for making sure that the ``ListsController`` knows about the current set of iCloud documents that are available.
///
/// There are also other responsibilities that a <code>ListCoordinator
/// </code> must have that are specific to the
/// underlying storage mechanism of the coordinator. A <code>ListCoordinator
/// </code> determines whether or not a
/// new list can be created with a specific name, it removes URLs tied to a specific list, and it is
/// also responsible for listening for updates to any changes that occur at a specific URL (e.g. a
/// list document is updated on another device, etc.).
///
/// Instances of <code>ListCoordinator
/// </code> can search for URLs in an asynchronous way. When a new <code>NSURL
/// </code>
/// instance is found, removed, or updated, the <code>ListCoordinator
/// </code> instance must make its delegate aware
/// of the updates. If a failure occured in removing or creating an <code>NSURL
/// </code> for a given list, it must
/// make its delegate aware by calling one of the appropriate error methods defined in the
/// <code>ListCoordinatorDelegate
/// </code> protocol.
SWIFT_PROTOCOL("_TtP9ListerKit15ListCoordinator_")
@protocol ListCoordinator

/// The delegate responsible for handling inserts, removes, updates, and errors when the ``ListCoordinator`` instance determines such events occured.
@property (nonatomic, weak) id <ListCoordinatorDelegate> __nullable delegate;

/// Starts observing changes to the important ``NSURL`` instances. For example, if a ``ListCoordinator`` conforming class has the responsibility to manage iCloud documents, the ``startQuery()`` method would start observing an ``NSMetadataQuery``. This method is called on the ``ListCoordinator`` once the coordinator is set on the ``ListsController``.
- (void)startQuery;

/// Stops observing changes to the important ``NSURL`` instances. For example, if a ``ListCoordinator`` conforming class has the responsibility to manage iCloud documents, the stopQuery() method would stop observing changes to the ``NSMetadataQuery``. This method is called on the ``ListCoordinator`` once a new ``ListCoordinator`` has been set on the ``ListsController``.
- (void)stopQuery;

/// Removes ``URL`` from the list of tracked ``NSURL`` instances. For example, an iCloud-specific ``ListCoordinator`` would implement this method by deleting the underlying document that ``URL`` represents. When ``URL`` is removed, the coordinator object is responsible for informing the delegate by calling ``listCoordinatorDidUpdateContents(insertedURLs:removedURLs:updatedURLs:)`` with the removed ``NSURL``. If a failure occurs when removing ``URL``, the coordinator object is responsible for informing the delegate by calling the ``listCoordinatorDidFailRemovingListAtURL(_:withError:)`` method. The ``ListsController`` is the only object that should be calling this method directly. The "remove" is intended to be called on the ``ListsController`` instance with a ``ListInfo`` object whose URL would be forwarded down to the coordinator through this method.
///
/// \param URL The <code>NSURL
/// </code> instance to remove from the list of important instances.
- (void)removeListAtURL:(NSURL * __nonnull)URL;

/// Creates an ``NSURL`` object representing ``list`` with the provided name. Callers of this method (which should only be the ``ListsController`` object) should first check to see if a list can be created with the provided name via the ``canCreateListWithName(_:)`` method. If the creation was successful, then this method should call the delegate's update method that passes the newly tracked ``NSURL`` as an inserted URL. If the creation was not successful, this method should inform the delegate of the failure by calling its ``listCoordinatorDidFailCreatingListAtURL(_:withError:)`` method. The "create" is intended to be called on the ``ListsController`` instance with a ``ListInfo`` object whose URL would be forwarded down to the coordinator through this method.
///
/// \param list The list to create a backing <code>NSURL
/// </code> for.
///
/// \param name The new name for the list.
- (void)createURLForList:(List * __nonnull)list withName:(NSString * __nonnull)name;

/// Checks to see if a list can be created with a given name. As an example, if a ``ListCoordinator`` instance was responsible for storing its lists locally as a document, the coordinator would check to see if there are any other documents on the file system that have the same name. If they do, the method would return ``false``. Otherwise, it would return ``true``. This method should only be called by the ``ListsController`` instance. Normally you would call the users will call the ``canCreateListWithName(_:)`` method on ``ListsController``, which will forward down to the current ``ListCoordinator`` instance.
///
/// \param name The name to use when checking to see if a list can be created.
///
/// \returns  <code>true
/// </code> if the list can be created with the given name, <code>false
/// </code> otherwise.
- (BOOL)canCreateListWithName:(NSString * __nonnull)name;

/// Attempts to copy a ``list`` at a given ``URL`` to the appropriate location in the documents directory.
///
/// \param URL The <code>NSURL
/// </code> object representing the list to be copied.
///
/// \param name The name of the <code>list
/// </code> to be overwritten.
- (void)copyListFromURL:(NSURL * __nonnull)URL toListWithName:(NSString * __nonnull)name;
@end



/// An object that conforms to the ``CloudListCoordinator`` protocol and is responsible for implementing entry points in order to communicate with an ``ListCoordinatorDelegate``. In the case of Lister, this is the ``ListsController`` instance. The main responsibility of a ``CloudListCoordinator`` is to track different ``NSURL`` instances that are important. The iCloud coordinator is responsible for making sure that the ``ListsController`` knows about the current set of iCloud documents that are available.
///
/// There are also other responsibilities that an <code>CloudListCoordinator
/// </code> must have that are specific
/// to the underlying storage mechanism of the coordinator. A <code>CloudListCoordinator
/// </code> determines whether
/// or not a new list can be created with a specific name, it removes URLs tied to a specific list, and
/// it is also responsible for listening for updates to any changes that occur at a specific URL
/// (e.g. a list document is updated on another device, etc.).
///
/// Instances of <code>CloudListCoordinator
/// </code> can search for URLs in an asynchronous way. When a new <code>NSURL
/// </code>
/// instance is found, removed, or updated, the <code>ListCoordinator
/// </code> instance must make its delegate
/// aware of the updates. If a failure occured in removing or creating an <code>NSURL
/// </code> for a given list,
/// it must make its delegate aware by calling one of the appropriate error methods defined in the
/// <code>ListCoordinatorDelegate
/// </code> protocol.
SWIFT_CLASS("_TtC9ListerKit20CloudListCoordinator")
@interface CloudListCoordinator <ListCoordinator>
@property (nonatomic, weak) id <ListCoordinatorDelegate> __nullable delegate;

/// Initializes an ``CloudListCoordinator`` based on a path extension used to identify files that can be managed by the app. Also provides a block parameter that can be used to provide actions to be executed when the coordinator returns its first set of documents. This coordinator monitors the app's iCloud Drive container.
///
/// \param pathExtension The extension that should be used to identify documents of interest to this coordinator.
///
/// \param firstQueryUpdateHandler The handler that is executed once the first results are returned.
- (nonnull instancetype)initWithPathExtension:(NSString * __nonnull)pathExtension firstQueryUpdateHandler:(void (^ __nullable)(void))firstQueryUpdateHandler;

/// Initializes an ``CloudListCoordinator`` based on a single document used to identify a file that should be monitored. Also provides a block parameter that can be used to provide actions to be executed when the coordinator returns its initial result. This coordinator monitors the app's iCloud Drive container.
///
/// \param lastPathComponent The file name that should be monitored by this coordinator.
///
/// \param firstQueryUpdateHandler The handler that is executed once the first results are returned.
- (nonnull instancetype)initWithLastPathComponent:(NSString * __nonnull)lastPathComponent firstQueryUpdateHandler:(void (^ __nullable)(void))firstQueryUpdateHandler;
- (void)startQuery;
- (void)stopQuery;
- (void)createURLForList:(List * __nonnull)list withName:(NSString * __nonnull)name;
- (BOOL)canCreateListWithName:(NSString * __nonnull)name;
- (void)copyListFromURL:(NSURL * __nonnull)URL toListWithName:(NSString * __nonnull)name;
- (void)removeListAtURL:(NSURL * __nonnull)URL;
@end



/// The ``IncompleteListItemsPresenter`` list presenter is responsible for managing the how a list's incomplete list items are displayed in the iOS and OS X Today widgets as well as the Lister WatchKit app. The ``IncompleteListItemsPresenter`` class conforms to ``ListPresenterType`` so consumers of this class can work with the presenter using a common interface.
///
/// When a list is initially presented with an <code>IncompleteListItemsPresenter
/// </code>, only the incomplete list items
/// are presented. That can change, however, if a user toggles list items (changing the list item's completion
/// state). An <code>IncompleteListItemsPresenter
/// </code> always shows the list items that are initially presented (unless
/// they are removed from the list from another device). If an <code>IncompleteListItemsPresenter
/// </code> stops presenting
/// a list that has some presented list items that are complete (after toggling them) and another
/// <code>IncompleteListItemsPresenter
/// </code> presents the same list, the presenter displays <em>only</em> the incomplete list
/// items.
///
/// The <code>IncompleteListItemsPresenter
/// </code> can be interacted with in a two ways. <code>ListItem
/// </code> instances can be
/// toggled individually or using a batch update, and the color of the list presenter can be changed.  All of
/// these methods trigger calls to the delegate to be notified about inserted list items, removed list items,
/// updated list items, etc.
SWIFT_CLASS("_TtC9ListerKit28IncompleteListItemsPresenter")
@interface IncompleteListItemsPresenter : NSObject
@property (nonatomic, readonly) List * __nonnull archiveableList;
@property (nonatomic, readonly, copy) NSArray<ListItem *> * __nonnull presentedListItems;

/// This methods determines the changes betwen the current list and the new list provided, and it notifies the delegate accordingly. The delegate is notified of all changes except for reordering list items (an implementation detail). If the list is the initial list to be presented, we just reload all of the data.
- (void)setList:(List * __nonnull)newList;

/// Toggles ``listItem`` within the list. This method keeps the list item in the same place, but it toggles the completion state of the list item. Toggling a list item calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method.
///
/// \param listItem The list item to toggle.
- (void)toggleListItem:(ListItem * __nonnull)listItem;

/// Sets all of the presented list item's completion states to ``completionState``. This method does not move the list items around in any way. Changing the completion state on all of the list items calls the delegate's ``listPresenter(_:didUpdateListItem:atIndex:)`` method for each list item that has been updated.
///
/// \param completionState The value that all presented list item instances should have as their <code>isComplete
/// </code> property.
- (void)updatePresentedListItemsToCompletionState:(BOOL)completionState;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The ``List`` class manages the color of a list and each ``ListItem`` object. ``List`` objects are copyable and archivable. ``List`` objects are normally associated with an object that conforms to ``ListPresenterType``. This object manages how the list is presented, archived, and manipulated. To ensure that the ``List`` class is unarchivable from an instance that was archived in the Objective-C version of Lister, the ``List`` class declaration is annotated with @objc(AAPLList). This annotation ensures that the runtime name of the ``List`` class is the same as the ``AAPLList`` class defined in the Objective-C version of the app. It also allows the Objective-C version of Lister to unarchive a ``List`` instance that was archived in the Swift version.
SWIFT_CLASS("AAPLList")
@interface List : NSObject <NSCoding, NSCopying>

/// The list's items.
@property (nonatomic, copy) NSArray<ListItem *> * __nonnull items;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * __nonnull)aCoder;
- (id __nonnull)copyWithZone:(NSZone * __null_unspecified)zone;

/// Overrides NSObject's isEqual(_:) instance method to return whether the list is equal to another list. A ``List`` is considered to be equal to another ``List`` if its color and items are equal.
///
/// \param object Any object, or nil.
///
/// \returns  <code>true
/// </code> if the object is a <code>List
/// </code> and it has the same color and items as the receiving
/// instance. <code>false
/// </code> otherwise.
- (BOOL)isEqual:(id __nullable)object;
@property (nonatomic, readonly, copy) NSString * __nonnull debugDescription;
@end


@class NSError;


/// The ``ListCoordinatorDelegate`` protocol exists to allow ``ListCoordinator`` instances to forward events. These events include a ``ListCoordinator`` removing, inserting, and updating their important, tracked ``NSURL`` instances. The ``ListCoordinatorDelegate`` also allows a ``ListCoordinator`` to notify its delegate of any errors that occured when removing or creating a list for a given URL.
SWIFT_PROTOCOL("_TtP9ListerKit23ListCoordinatorDelegate_")
@protocol ListCoordinatorDelegate

/// Notifies the ``ListCoordinatorDelegate`` instance of any changes to the tracked URLs of the ``ListCoordinator``. For more information about when this method should be called, see the description for the other ``ListCoordinator`` methods mentioned above that manipulate the tracked ``NSURL`` instances.
///
/// \param insertedURLs The <code>NSURL
/// </code> instances that are newly tracked.
///
/// \param removedURLs The <code>NSURL
/// </code> instances that have just been untracked.
///
/// \param updatedURLs The <code>NSURL
/// </code> instances that have had their underlying model updated.
- (void)listCoordinatorDidUpdateContentsWithInsertedURLs:(NSArray<NSURL *> * __nonnull)insertedURLs removedURLs:(NSArray<NSURL *> * __nonnull)removedURLs updatedURLs:(NSArray<NSURL *> * __nonnull)updatedURLs;

/// Notifies a ``ListCoordinatorDelegate`` instance of an error that occured when a coordinator tried to remove a specific URL from the tracked ``NSURL`` instances. For more information about when this method should be called, see the description for the ``removeListAtURL(_:)`` method on ``ListCoordinator``.
///
/// \param URL The <code>NSURL
/// </code> instance that failed to be removed.
///
/// \param error The error that describes why the remove failed.
- (void)listCoordinatorDidFailRemovingListAtURL:(NSURL * __nonnull)URL withError:(NSError * __nonnull)error;

/// Notifies a ``ListCoordinatorDelegate`` instance of an error that occured when a coordinator tried to create a list at a given URL. For more information about when this method should be called, see the description for the ``createURLForList(_:withName:)`` method on ``ListCoordinator``.
///
/// \param URL The <code>NSURL
/// </code> instance that couldn't be created for a list.
///
/// \param error The error the describes why the create failed.
- (void)listCoordinatorDidFailCreatingListAtURL:(NSURL * __nonnull)URL withError:(NSError * __nonnull)error;
@end

@class NSUserActivity;
@protocol ListDocumentDelegate;

SWIFT_CLASS("_TtC9ListerKit12ListDocument")
@interface ListDocument : UIDocument
@property (nonatomic, weak) id <ListDocumentDelegate> __nullable delegate;
- (BOOL)loadFromContents:(id __nonnull)contents ofType:(NSString * __nullable)typeName error:(NSError * __nullable * __null_unspecified)error;
- (id __nullable)contentsForType:(NSString * __nonnull)typeName error:(NSError * __nullable * __null_unspecified)error;
- (void)saveToURL:(NSURL * __nonnull)url forSaveOperation:(UIDocumentSaveOperation)saveOperation completionHandler:(void (^ __nullable)(BOOL))completionHandler;
- (void)accommodatePresentedItemDeletionWithCompletionHandler:(void (^ __nonnull)(NSError * __nullable))completionHandler;
- (void)updateUserActivityState:(NSUserActivity * __nonnull)userActivity;
@end



/// Protocol that allows a list document to notify other objects of it being deleted.
SWIFT_PROTOCOL("_TtP9ListerKit20ListDocumentDelegate_")
@protocol ListDocumentDelegate
- (void)listDocumentWasDeleted:(ListDocument * __nonnull)listDocument;
@end


SWIFT_CLASS("_TtC9ListerKit8ListInfo")
@interface ListInfo : NSObject
@property (nonatomic, readonly) NSURL * __nonnull URL;
@property (nonatomic, readonly, copy) NSString * __nonnull name;
- (nonnull instancetype)initWithURL:(NSURL * __nonnull)URL OBJC_DESIGNATED_INITIALIZER;
- (void)fetchInfoWithCompletionHandler:(void (^ __nonnull)(void))completionHandler;
- (BOOL)isEqual:(id __nullable)object;
@end



/// A ``ListItem`` object is composed of a text property, a completion status, and an underlying opaque identity that distinguishes one ``ListItem`` object from another. ``ListItem`` objects are copyable and archivable. To ensure that the ``ListItem`` class is unarchivable from an instance that was archived in the Objective-C version of Lister, the ``ListItem`` class declaration is annotated with @objc(AAPLListItem). This annotation ensures that the runtime name of the ``ListItem`` class is the same as the ``AAPLListItem`` class defined in the Objective-C version of the app. It also allows the Objective-C version of Lister to unarchive a ``ListItem`` instance that was archived in the Swift version.
SWIFT_CLASS("AAPLListItem")
@interface ListItem : NSObject <NSCoding, NSCopying>

/// The text content for a ``ListItem``.
@property (nonatomic, copy) NSString * __nonnull text;

/// Whether or not this ``ListItem`` is complete.
@property (nonatomic) BOOL isComplete;

/// Initializes a ``ListItem`` instance with the designated text and completion state.
///
/// \param text The text content of the list item.
///
/// \param complete The item's initial completion state.
- (nonnull instancetype)initWithText:(NSString * __nonnull)text complete:(BOOL)complete;

/// Initializes a ``ListItem`` instance with the designated text and a default value for ``isComplete``. The default value for ``isComplete`` is false.
///
/// \param text The intended text content of the list item.
- (nonnull instancetype)initWithText:(NSString * __nonnull)text;
- (id __nonnull)copyWithZone:(NSZone * __null_unspecified)zone;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * __nonnull)encoder;

/// Resets the underlying identity of the ``ListItem``. If a copy of this item is made, and a call to refreshIdentity() is made afterward, the items will no longer be equal.
- (void)refreshIdentity;

/// Overrides NSObject's isEqual(_:) instance method to return whether or not the list item is equal to another list item. A ``ListItem`` is considered to be equal to another ``ListItem`` if the underyling identities of the two list items are equal.
///
/// \param object Any object, or nil.
///
/// \returns  <code>true
/// </code> if the object is a <code>ListItem
/// </code> and it has the same underlying identity as the
/// receiving instance. <code>false
/// </code> otherwise.
- (BOOL)isEqual:(id __nullable)object;
@property (nonatomic, readonly, copy) NSString * __nonnull debugDescription;
@end

@class NSOperationQueue;
@protocol ListsControllerDelegate;


/// The ``ListsController`` class is responsible for tracking ``ListInfo`` objects that are found through lists controller's ``ListCoordinator`` object. ``ListCoordinator`` objects are responsible for notifying the lists controller of inserts, removes, updates, and errors when interacting with a list's URL. Since the work of searching, removing, inserting, and updating ``ListInfo`` objects is done by the list controller's coordinator, the lists controller serves as a way to avoid the need to interact with a single ``ListCoordinator`` directly throughout the application. It also allows the rest of the application to deal with ``ListInfo`` objects rather than dealing with their ``NSURL`` instances directly. In essence, the work of a lists controller is to "front" its current coordinator. All changes that the coordinator relays to the ``ListsController`` object will be relayed to the lists controller's delegate. This ability to front another object is particularly useful when the underlying coordinator changes. As an example, this could happen when the user changes their storage option from using local documents to using cloud documents. If the coordinator property of the lists controller changes, other objects throughout the application are unaffected since the lists controller will notify them of the appropriate changes (removes, inserts, etc.).
SWIFT_CLASS("_TtC9ListerKit15ListsController")
@interface ListsController : NSObject <ListCoordinatorDelegate>

/// The ``ListsController``'s delegate who is responsible for responding to ``ListsController`` updates.
@property (nonatomic, weak) id <ListsControllerDelegate> __nullable delegate;

/// \returns  The number of tracked <code>ListInfo
/// </code> objects.
@property (nonatomic, readonly) NSInteger count;

/// The current ``ListCoordinator`` that the lists controller manages.
@property (nonatomic) id <ListCoordinator> __nonnull listCoordinator;

/// Initializes a ``ListsController`` instance with an initial ``ListCoordinator`` object and a sort predicate (if any). If no sort predicate is provided, the controller ignores sort order.
///
/// \param listCoordinator The <code>ListsController
/// </code>'s initial <code>ListCoordinator
/// </code>.
///
/// \param delegateQueue The queue on which the <code>ListsController
/// </code> object invokes delegate messages.
///
/// \param sortPredicate The predicate that determines the strict sort ordering of the <code>listInfos
/// </code> array.
- (nonnull instancetype)initWithListCoordinator:(id <ListCoordinator> __nonnull)listCoordinator delegateQueue:(NSOperationQueue * __nonnull)delegateQueue sortPredicate:(BOOL (^ __nullable)(ListInfo * __nonnull, ListInfo * __nonnull))sortPredicate OBJC_DESIGNATED_INITIALIZER;
- (ListInfo * __nonnull)objectAtIndexedSubscript:(NSInteger)idx;

/// Begin listening for changes to the tracked ``ListInfo`` objects. This is managed by the ``listCoordinator`` object. Be sure to balance each call to ``startSearching()`` with a call to ``stopSearching()``.
- (void)startSearching;

/// Stop listening for changes to the tracked ``ListInfo`` objects. This is managed by the ``listCoordinator`` object. Each call to ``startSearching()`` should be balanced with a call to this method.
- (void)stopSearching;

/// Removes ``listInfo`` from the tracked ``ListInfo`` instances. This method forwards the remove operation directly to the list coordinator. The operation can be performed asynchronously so long as the underlying ``ListCoordinator`` instance sends the ``ListsController`` the correct delegate messages: either a ``listCoordinatorDidUpdateContents(insertedURLs:removedURLs:updatedURLs:)`` call with the removed ``ListInfo`` object, or with an error callback.
///
/// \param listInfo The <code>ListInfo
/// </code> to remove from the list of tracked <code>ListInfo
/// </code> instances.
- (void)removeListInfo:(ListInfo * __nonnull)listInfo;

/// Attempts to create ``ListInfo`` representing ``list`` with the given name. If the method is succesful, the lists controller adds it to the list of tracked ``ListInfo`` instances. This method forwards the create operation directly to the list coordinator. The operation can be performed asynchronously so long as the underlying ``ListCoordinator`` instance sends the ``ListsController`` the correct delegate messages: either a ``listCoordinatorDidUpdateContents(insertedURLs:removedURLs:updatedURLs:)`` call with the newly inserted ``ListInfo``, or with an error callback.
///
/// Note: it's important that before calling this method, a call to <code>canCreateListWithName(_:)
/// </code>
/// is performed to make sure that the name is a valid list name. Doing so will decrease the errors
/// that you see when you actually create a list.
///
/// \param list The <code>List
/// </code> object that should be used to save the initial list.
///
/// \param name The name of the new list.
- (void)createListInfoForList:(List * __nonnull)list withName:(NSString * __nonnull)name;

/// Determines whether or not a list can be created with a given name. This method delegates to ``listCoordinator`` to actually check to see if the list can be created with the given name. This method should be called before ``createListInfoForList(_:withName:)`` is called to ensure to minimize the number of errors that can occur when creating a list.
///
/// \param name The name to check to see if it's valid or not.
///
/// \returns  <code>true
/// </code> if the list can be created with the given name, <code>false
/// </code> otherwise.
- (BOOL)canCreateListInfoWithName:(NSString * __nonnull)name;

/// Attempts to copy a ``list`` at a given ``URL`` to the appropriate location in the documents directory. This method forwards to ``listCoordinator`` to actually perform the document copy.
///
/// \param URL The <code>NSURL
/// </code> object representing the list to be copied.
///
/// \param name The name of the <code>list
/// </code> to be overwritten.
- (void)copyListFromURL:(NSURL * __nonnull)URL toListWithName:(NSString * __nonnull)name;

/// Lets the ``ListsController`` know that ``listInfo`` has been udpdated. Once the change is reflected in ``listInfos`` array, a didUpdateListInfo message is sent.
///
/// \param listInfo The <code>ListInfo
/// </code> instance that has new content.
- (void)setListInfoHasNewContents:(ListInfo * __nonnull)listInfo;

/// Receives changes from ``listCoordinator`` about inserted, removed, and/or updated ``ListInfo`` objects. When any of these changes occurs, these changes are processed and forwarded along to the ``ListsController`` object's delegate. This implementation determines where each of these URLs were located so that the controller can forward the new / removed / updated indexes as well. For more information about this method, see the method description for this method in the ``ListCoordinator`` class.
///
/// \param insertedURLs The <code>NSURL
/// </code> instances that should be tracekd.
///
/// \param removedURLs The <code>NSURL
/// </code> instances that should be untracked.
///
/// \param updatedURLs The <code>NSURL
/// </code> instances that have had their underlying model updated.
- (void)listCoordinatorDidUpdateContentsWithInsertedURLs:(NSArray<NSURL *> * __nonnull)insertedURLs removedURLs:(NSArray<NSURL *> * __nonnull)removedURLs updatedURLs:(NSArray<NSURL *> * __nonnull)updatedURLs;

/// Forwards the "create" error from the ``ListCoordinator`` to the ``ListsControllerDelegate``. For more information about when this method can be called, see the description for this method in the ``ListCoordinatorDelegate`` protocol description.
///
/// \param URL The <code>NSURL
/// </code> instances that was failed to be created.
///
/// \param error The error the describes why the create failed.
- (void)listCoordinatorDidFailCreatingListAtURL:(NSURL * __nonnull)URL withError:(NSError * __nonnull)error;

/// Forwards the "remove" error from the ``ListCoordinator`` to the ``ListsControllerDelegate``. For more information about when this method can be called, see the description for this method in the ``ListCoordinatorDelegate`` protocol description.
///
/// \param URL The <code>NSURL
/// </code> instance that failed to be removed
///
/// \param error The error that describes why the remove failed.
- (void)listCoordinatorDidFailRemovingListAtURL:(NSURL * __nonnull)URL withError:(NSError * __nonnull)error;
@end



/// The ``ListsControllerDelegate`` protocol enables a ``ListsController`` object to notify other objects of changes to available ``ListInfo`` objects. This includes "will change content" events, "did change content" events, inserts, removes, updates, and errors. Note that the ``ListsController`` can call these methods on an aribitrary queue. If the implementation in these methods require UI manipulations, you should respond to the changes on the main queue.
SWIFT_PROTOCOL("_TtP9ListerKit23ListsControllerDelegate_")
@protocol ListsControllerDelegate
@optional

/// Notifies the receiver of this method that the lists controller will change it's contents in some form. This method is *always* called before any insert, remove, or update is received. In this method, you should prepare your UI for making any changes related to the changes that you will need to reflect once they are received. For example, if you have a table view in your UI that needs to respond to changes to a newly inserted ``ListInfo`` object, you would want to call your table view's ``beginUpdates()`` method. Once all of the updates are performed, your ``listsControllerDidChangeContent(_:)`` method will be called. This is where you would to call your table view's ``endUpdates()`` method.
///
/// \param listsController The <code>ListsController
/// </code> instance that will change its content.
- (void)listsControllerWillChangeContent:(ListsController * __nonnull)listsController;

/// Notifies the receiver of this method that the lists controller is tracking a new ``ListInfo`` object. Receivers of this method should update their UI accordingly.
///
/// \param listsController The <code>ListsController
/// </code> instance that inserted the new <code>ListInfo
/// </code>.
///
/// \param listInfo The new <code>ListInfo
/// </code> object that has been inserted at <code>index
/// </code>.
///
/// \param index The index that <code>listInfo
/// </code> was inserted at.
- (void)listsController:(ListsController * __nonnull)listsController didInsertListInfo:(ListInfo * __nonnull)listInfo atIndex:(NSInteger)index;

/// Notifies the receiver of this method that the lists controller received a message that ``listInfo`` has updated its content. Receivers of this method should update their UI accordingly.
///
/// \param listsController The <code>ListsController
/// </code> instance that was notified that <code>listInfo
/// </code> has been updated.
///
/// \param listInfo The <code>ListInfo
/// </code> object that has been updated.
///
/// \param index The index of <code>listInfo
/// </code>, the updated <code>ListInfo
/// </code>.
- (void)listsController:(ListsController * __nonnull)listsController didRemoveListInfo:(ListInfo * __nonnull)listInfo atIndex:(NSInteger)index;

/// Notifies the receiver of this method that the lists controller is no longer tracking ``listInfo``. Receivers of this method should update their UI accordingly.
///
/// \param listsController The <code>ListsController
/// </code> instance that removed <code>listInfo
/// </code>.
///
/// \param listInfo The removed <code>ListInfo
/// </code> object.
///
/// \param index The index that <code>listInfo
/// </code> was removed at.
- (void)listsController:(ListsController * __nonnull)listsController didUpdateListInfo:(ListInfo * __nonnull)listInfo atIndex:(NSInteger)index;

/// Notifies the receiver of this method that the lists controller did change it's contents in some form. This method is *always* called after any insert, remove, or update is received. In this method, you should finish off changes to your UI that were related to any insert, remove, or update. For an example of how you might handle a "did change" contents call, see the discussion for ``listsControllerWillChangeContent(_:)``.
///
/// \param listsController The <code>ListsController
/// </code> instance that did change its content.
- (void)listsControllerDidChangeContent:(ListsController * __nonnull)listsController;

/// Notifies the receiver of this method that an error occured when creating a new ``ListInfo`` object. In implementing this method, you should present the error to the user. Do not rely on the ``ListInfo`` instance to be valid since an error occured in creating the object.
///
/// \param listsController The <code>ListsController
/// </code> that is notifying that a failure occured.
///
/// \param listInfo The <code>ListInfo
/// </code> that represents the list that couldn't be created.
///
/// \param error The error that occured.
- (void)listsController:(ListsController * __nonnull)listsController didFailCreatingListInfo:(ListInfo * __nonnull)listInfo withError:(NSError * __nonnull)error;

/// Notifies the receiver of this method that an error occured when removing an existing ``ListInfo`` object. In implementing this method, you should present the error to the user.
///
/// \param listsController The <code>ListsController
/// </code> that is notifying that a failure occured.
///
/// \param listInfo The <code>ListInfo
/// </code> that represents the list that couldn't be removed.
///
/// \param error The error that occured.
- (void)listsController:(ListsController * __nonnull)listsController didFailRemovingListInfo:(ListInfo * __nonnull)listInfo withError:(NSError * __nonnull)error;
@end



/// An object that conforms to the ``LocalListCoordinator`` protocol and is responsible for implementing entry points in order to communicate with an ``ListCoordinatorDelegate``. In the case of Lister, this is the ``ListsController`` instance. The main responsibility of a ``LocalListCoordinator`` is to track different ``NSURL`` instances that are important. The local coordinator is responsible for making sure that the ``ListsController`` knows about the current set of documents that are available in the app's local container.
///
/// There are also other responsibilities that an <code>LocalListCoordinator
/// </code> must have that are specific
/// to the underlying storage mechanism of the coordinator. A <code>CloudListCoordinator
/// </code> determines whether
/// or not a new list can be created with a specific name, it removes URLs tied to a specific list, and
/// it is also responsible for listening for updates to any changes that occur at a specific URL
/// (e.g. a list document is updated on another device, etc.).
///
/// Instances of <code>LocalListCoordinator
/// </code> can search for URLs in an asynchronous way. When a new <code>NSURL
/// </code>
/// instance is found, removed, or updated, the <code>ListCoordinator
/// </code> instance must make its delegate
/// aware of the updates. If a failure occured in removing or creating an <code>NSURL
/// </code> for a given list,
/// it must make its delegate aware by calling one of the appropriate error methods defined in the
/// <code>ListCoordinatorDelegate
/// </code> protocol.
SWIFT_CLASS("_TtC9ListerKit20LocalListCoordinator")
@interface LocalListCoordinator <ListCoordinator>
@property (nonatomic, weak) id <ListCoordinatorDelegate> __nullable delegate;

/// Initializes an ``LocalListCoordinator`` based on a path extension used to identify files that can be managed by the app. Also provides a block parameter that can be used to provide actions to be executed when the coordinator returns its first set of documents. This coordinator monitors the app's local container.
///
/// \param pathExtension The extension that should be used to identify documents of interest to this coordinator.
///
/// \param firstQueryUpdateHandler The handler that is executed once the first results are returned.
- (nonnull instancetype)initWithPathExtension:(NSString * __nonnull)pathExtension firstQueryUpdateHandler:(void (^ __nullable)(void))firstQueryUpdateHandler OBJC_DESIGNATED_INITIALIZER;

/// Initializes an ``LocalListCoordinator`` based on a single document used to identify a file that should be monitored. Also provides a block parameter that can be used to provide actions to be executed when the coordinator returns its initial result. This coordinator monitors the app's local container.
///
/// \param lastPathComponent The file name that should be monitored by this coordinator.
///
/// \param firstQueryUpdateHandler The handler that is executed once the first results are returned.
- (nonnull instancetype)initWithLastPathComponent:(NSString * __nonnull)lastPathComponent firstQueryUpdateHandler:(void (^ __nullable)(void))firstQueryUpdateHandler OBJC_DESIGNATED_INITIALIZER;
- (void)startQuery;
- (void)stopQuery;
- (void)removeListAtURL:(NSURL * __nonnull)URL;
- (void)createURLForList:(List * __nonnull)list withName:(NSString * __nonnull)name;
- (BOOL)canCreateListWithName:(NSString * __nonnull)name;
- (void)copyListFromURL:(NSURL * __nonnull)URL toListWithName:(NSString * __nonnull)name;
- (void)processChangeToLocalDocumentsDirectory;
@end

#pragma clang diagnostic pop
